<html>
<head>
<title>Yadex hacker's guide</title>
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css">
  DT {
    margin-bottom:       1em;
    margin-top:          1em;
    display:             list-item;
    list-style-image:    none;
    list-style-position: inside;
    list-style-type:     disc;
  }
  DD {
    margin-bottom: 1em;
    margin-top:    1em
  }
</style>
</head>
<body>

<div align="center">
<img src="logo_small.png" alt="Fancy logo">
<br>Yadex $VERSION ($SOURCE_DATE)
<h1>Hacker's guide</h1>
</div>
<br>
<br>
<br>

		<h2>Read this first</h2>

Before you start hacking&mdash;no, before you even
<em>think</em> about hacking&mdash;Yadex, you should do
this&nbsp;:

<dl>
  <dt>Read the <a href="TODO"><code>TODO</code></a> file

  <dd>
    Many possible improvements and fixes have been identified
    and sometimes a particular approach has already been decided
    on and written down in <code>TODO</code>. Yes it's tedious
    reading. But if you skip it, you run the risk of seeing your
    work go to waste because it's in conflict with an earlier
    plan.

  <dt>Read the <a href="hackers_guide.html">hacker's guide</a>

  <dd>
    Patches that don't <em>at the minimum</em> abide by the
    coding standards and other guidelines in this document are
    not very likely to be accepted.

  <dt>Subscribe to the <a
    href="contact.html#list_yadex"><code>yadex</code> list</a>

  <dd>
    The mailing list is the way by which users and developers
    communicate. Subscribe to the list and do all communication
    through the list. It allows developers to coordinate and to
    benefit from the feedback of all other developers and users.
    
    <p>
      For whatever reason, some contributors seem to think they
      don't need to subscribe to the list. But the need for
      coordination remains. Each contributor needs a
      communication channel with the rest of the project. If
      it's not the mailing list, it'll probably be the
      maintainer (me) and I don't want to have to play the role
      of a mailing list digest server.
    </p>

    <p>
      Having a single many-to-many communication channel is
      better than having many one-to-one channels because you
      don't have to repeat the same thing <var>n</var> times to
      <var>n</var> people.
    </p>

    <p>
      The mailing list is archived and the archives are publicly
      accessible by anyone at any time. Private mail isn't.
    </p>

  <dt>Post on the list about your plans
  
  <dd>
    The job you want to do might be already underway, or might
    be conflicting with something else.

</dl>

		<h2>Blah</h2>

			<h3>Foreword</h3>

This documents is aimed at people
who want to hack Yadex.
It is very incomplete,
partly due to lack of time,
partly because as some subsystems are going to be rewritten,
I'd rather not spend too much time documenting them.
But if you're interested in a particular area
of Yadex's bowels that does not appear here,
don't hesitate to let me know.
<p>
I apologize for the poor quality of Yadex's code
but it seemed to me it was better to release
something imperfect now
than something clean two years from now.
If you want to improve it, be my guest.

			<h3>Introduction</h3>

Yadex is written in a mixture of C and C++.
The Unix version interfaces with X through Xlib directly&nbsp;;
it uses no toolkit.
The DOS version uses BGI (Borland Graphics Interface),
a rather low-level API to set the video mode, draw lines, text, etc.

			<h3>Original platform</h3>

The Unix version has been developped with
GCC 2.7.2, EGCS 1.0.3, EGCS 1.1.1, libc5, glibc2 and XFree 3.3
on a PC K6/200 with Linux 2.0.29, 2.0.30 and 2.0.34.
<p>
The DOS version has been developped with
Borland C++ 4.0
on a PC 486 DX4/75 with MS-DOS 6.22.
<p>
Yadex should be compilable on all reasonable
Unix-and-X11 platforms provided that 
<ul>
<li>you have GNU make,
<li>you have a C compiler and a C++ compiler,
<li>$c short is 16-bit long,
<li>$c long is 32-bit long.
</ul>
To compile on platforms where $c short
or $c long don't have the needed size,
just change the definitions of $c u16,
$c i16, $c u32 and $c i32
in $c yadex.h.

			<h3>Historic background</h3>

Yadex descends from DEU 5.21.
<p>
DEU 5.21 was written by Raphaël Quinet, Brendon Wyber and others
and released on 1994-05-21.
As you probably already know,
DEU was a real-mode DOS program,
in C, compiled with Borland C++ 4.0 (I think)
and using BGI for its output.
<p>
In the mists of time (that is probably 1996),
I began to hack DEU for my own use.
In 1997, other people began to use my hack
and I gave it a name : "Yade"
(which meant Yet Another Doom Editor).
It was still a real-mode DOS program.
<p>
In june 1998, tired of rebooting to DOS
every time I wanted to do some Doom level editing,
I started porting Yade to Linux.
As there already was a Unix program called "Yade"
(Yet Another Diagram Editor),
I changed the name of my baby to "Yadex".
At the same time, I began to use C++ in places
so that's why Yadex is such an ugly mixture of languages.

		<h2>Development cycle</h2>

			<h3>Compiling, installing, testing</h3>

<p>OK. So I want to hack Yadex&nbsp;; what do I do now&nbsp;?
The obvious development cycle is

<ol>
  <li>modify the files in <code>src/</code>,
  <li>type <code>make</code>,
  <li>type <code>su -c 'make install'</code>,
  <li>run Yadex and test.
</ol>

<p>However, there are a few things to know that can make you
more efficient.

<p>To compile with debugging information, you don't have to
modifiy the makefile&nbsp;; just use the appropriate target
(<code>dyadex</code>). The resulting executable is put in
<code>dobj/0/</code> instead of <code>obj/0/</code>.

<p>You don't have to install to test&nbsp;: you can test in
place with the special targets <code>test</code> and
<code>dtest</code> (<code>test</code> is for the regular
executable, <code>dtest</code> is for the debugging executable
and is my favourite target by far). When testing through make,
you can't pass arguments to Yadex directly&nbsp;: you have to
pass them through the <code>A</code> macro. For example&nbsp;:

<pre>  $ <b>make dtest A='-g heretic foo.wad'</b></pre>
 
<p>You can also run your hack through the debugger with the
<code>dg</code> (GDB) and <code>dd</code> (DDD) targets. With
those targets, you can't use the <code>A=</code>
convention&nbsp;: you have to type "<code>set args blah blah
blah</code>" at the debugger prompt.

<pre>  $ <b>make dg</b>
  (gdb) <b>set args -g heretic foo.wad</b>
  (gdb) <b>run</b></pre>

<p>Even if you want to install your hack, you may want to keep
the original Yadex around, for reference or for a good laugh.
To do that, edit the <code>VERSION</code> file before compiling
your hack. If your hack bears a different version number, it
will not overwrite the original version. You don't have to
change the version number much&nbsp;: you can just change
"<code>3.8.0</code>" into "<code>3.8.0a</code>" or
"<code>3.8.0.0</code>" for example.

<p>

		<h2>The programming environment</h2>

			<h3>Memory allocation</h3>

You're not supposed to use $c malloc() and $c free() but $c
GetMemory(), $c FreeMemory(), $c GetFarMemory() and $c
FreeFarMemory() instead. Why ?

<p>$c GetMemory() and friends manage more things for you.  They
include an anti-fragmentation system, they try to swap things
out when memory is tight (this is an only an issue for the
16-bit DOS version) and if they fail, they call $c fatal_error()
so you don't need to check their return value.

<p>The reason for $c GetFarMemory() is that, for the 16-bit DOS
version, it can allocate more than 64 kB ($c GetMemory()
cannot). I must say that I don't use $c GetFarMemory() a lot
myself because I don't like the idea of having to use two
different memory allocation routines depending on the size I
expect to allocate. I modified $c GetMemory() so that it accepts
an <code>unsigned long</code> but checks that the passed value
fits in $c size_t. In other words, if you call $c GetMemory()
with a size of 65,536 the 16-bit DOS version will trigger a
fatal error immediately instead of silently allocating 1 byte
and letting you search afterwards why the program behaves
strangely. A better fix would be to make $c GetMemory() call $c
GetFarMemory() when the block is too large for $c malloc(). Any
volunteers ?

<p>Memory allocated with $c GetMemory() is guaranteed to be
freeable with $c free().  On the other hand, memory allocated
with $c GetFarMemory() must be freeed with $c FreeFarMemory().

			<h3><a name="endianness">Endianness</a></h3>

The 16-bit and 32-bit integers in a wad file are always
little-endian, whatever the platform.

<p>On the other hand, Yadex keeps all its in-core integer in the
platform's native endianness, i.e. in little-endian format on
little-endian machines and in big-endian format on big-endian
machines.

<p>The wad endianness &lt;-&gt; native endianness conversion is
done automagically by $c wad_read_i16() and $c wad_read_i32().

<p><u>To maintain compatibility with big-endian platforms, all
I/O of multibyte integers should be done with those
functions.</u>

		<h2>The directory</h2>

			<h3>Principle</h3>

Like Doom, Yadex accesses lumps through an indirection layer
that called the <i>directory</i>. The directory is basically a
list of all the lumps that exist in the iwad and/or at least one
of the pwads with, for each lump, the information necessary to
read it. Each directory entry has 4 fields&nbsp;; the name of
the lump, its offset in the wad, its length, and an indirect
pointer to the file descriptor for the wad that contains it.

<p>As you might expect, if the same lump is present in more than
one wad, it has only one directory entry, pointing to the last
occurence.

<p>When you need to load a lump by name, you call
<code>FindMasterDir()</code>.  It returns you a pointer on its
entry in the directory, which in turn contains everything you
need to read it.

			<h3>Managing the directory</h3>

<p>The directory is kept in memory at all times. It is only
modified when you initially load the iwad and when you load or
unload a pwad. And of course when you delete the directory.
Simple, isn't it&nbsp;?

<p>Ha-ha, gotcha, this is not how the actual API works. The
actual set of operations is somewhat different in that it does
not include unloading a pwad. Instead, there is a function to
close all unused pwads, that is pwads that are not referenced by
a single entry in the directory. I suppose that the reason why
it was done this way is that unloading a pwad is a bit more
complicated, since it involves finding the previous "provider"
of all lumps that the wad to unload used to "provide". I guess
the only way to do that would be rebuilding the directory from
scratch. This "feature" is discussed in the Comments section
below. Anyway, here is the API.

<dl>
<dt><code>OpenMainWad()</code>
<dd>Create the directory and fill it with the contents of the
directory of the iwad.

<dt><code>OpenPatchWad()</code> 
<dd>Add a pwad to the list of the open wads and to the
directory.

<dt><code>CloseUnusedWadFiles()</code>
<dd>Close all wads that are not used in the directory anymore.

<dt><code>CloseWadFiles()</code>
<dd>Close all open wads and delete the list of open wads and the
directory.
</dl>

			<h3>Implementation</h3>

It has not been said explicitly so far but Yadex maintains a
list of all open wads (iwads and pwads). It is a linked list of
the <code>WadFileInfo</code> structure. The global variable
<code>WadeFileList</code> is a pointer to the first element of
the list, which is always the iwad. The type <code>WadPtr</code>
is an alias for "<code>struct WadFileInfo *</code>" (yes, I
know, it's confusing to have two names for the same thing).

<pre>
struct WadFileInfo
   {
   WadPtr next;                 // Next file in linked list
   char *filename;              // Name of the wad file
   FILE *fd;                    // C file stream information
   char type[4];                // Type of wad file ("IWAD" or "PWAD")
   i32  dirsize;                // Directory size of wad
   i32  dirstart;               // Offset to start of directory
   DirPtr directory;            // Array of directory information
   };
typedef struct WadFileInfo *WadPtr;
extern WadPtr WadFileList;      // List of wad files
</pre>

<p>The directory itself is a linked list of the
<code>MasterDirectory</code> structure. The global variable
<code>MasterDir</code> points to the first element of the
directory. The type <code>MDirPtr</code> is an alias for
"<code>struct MasterDirectory *</code>".

<pre>
struct Directory
   {
   i32  start;                  // Offset to start of data
   i32  size;                   // Byte size of data
   char name[WAD_NAME];         // Name of data block
   };
struct MasterDirectory
   {
   MDirPtr next;                // Next in list
   WadPtr wadfile;              // File of origin
   struct Directory dir;        // Directory data (name, offset, size)
   };
typedef struct MasterDirectory *MDirPtr;
extern MDirPtr MasterDir;       // The master directory
</pre>

			<h3>Sample code</h3>

To be written : searching for a directory entry. The same thing,
in an incremental fashion.

			<h3>Comments</h3>

<p>The decision to use a directory is arguable. It is convenient
for the programmer when he/she is looking for the
<em>effective</em> instance of a lump, which is the case most of
the time. But it also prevents the user from editing a resource
(notably, a level), if it has been overridden in another wad.
It's not a big deal but I don't like it.

<p>The fact that the directory managing operations don't include
removing a pwad from the directory means that there is no way
for the user to "unload" a pwad. The "<code>read</code>" command
has no inverse. The only way to do it is to restart Yadex.

<p>Another somewhat non obvious design decision is that, in most
places where the directory is updated,
<code>CloseUnusedWadFiles()</code> is called too. This means
that you can't load two pwads that have exactly the same lumps.
As the second pwad is loaded, the first one is automatically
(and silently) unloaded. Not a big deal either but, as a user, I
don't like the programs I use to behave like that. I'll
illustrate my point with the following scenario, which assumes
the "unload pwad" function exists&nbsp;:
<ol>
<li>Load pwad A (MAP01)
<li>Load pwad B (MAP01)
<li>Unload pwad B
<li>Edit MAP01
</ol>
At this point, as you have backtracked on your action of loading
B, you would expect to see the MAP01 from A, wouldn't you&nbsp;?
Instead you get the MAP01 from the iwad, because A was unloaded
as you loaded B. From a user point of view, such a behaviour is
confusing and therefore to be avoided.

<p>I don't like the directory management API very much because
it's unexpectedly asymmetric and therefore neither intuitive nor
orthogonal. The way Yadex plays games with the directory is
really disgusting and confusing to me.

<p>I should look into replacing the iwad "on the fly", so that
the user is able to change the game parameter dynamically,
without restarting Yadex. In fact, the ultimate goal is to
remove the game parameter completely or, more precisely, to make
it local to a Level object, automatically adjusting and
dynamically modifiable by the user.

		<h2>The wad data</h2>

TBD

		<h2>The level data</h2>

			<h3>Structure</h3>

The data for a level is stored in 10 variables
that are declared in <code>levels.h</code> and
defined in <code>levels.cc</code>. Here they are :
<pre>int   NumThings;         /* number of things */
TPtr  Things;            /* things data */
int   NumLineDefs;       /* number of linedefs */
LDPtr LineDefs;          /* linedefs data */
int   NumSideDefs;       /* number of sidedefs */
SDPtr SideDefs;          /* sidedefs data */
int   NumVertices;       /* number of vertices */
VPtr  Vertices;          /* vertices data */
int   NumSectors;        /* number of sectors */
SPtr  Sectors;           /* sectors data */</pre>

			<h3>Scope and lifetime</h3>

Since those variables (and other critical ones)
are unfortunately static, it's not possible to
open editing windows on several different levels
simultaneously.
This should be fixed in the future by making the
level data a class and turning those variables
into members of that class.
<p>
I think that the level data class should be separate
from the editing window class because it might be
useful to open several editing windows on the same
level.
Separate class should also make the design of the read
level and write level routines cleaner and simpler.

			<h3>Maintenance</h3>

It's of paramount importance for the stability and
reliability of Yadex that the level data be maintained
in a consistent state at all times. In particular,
<ul>
<li>the $c Num* variables must remain accurate,
<li>vertex references in linedefs must be either
	$c OBJ_NO_NONE or the number of an existing vertex,
<li>sidedef references in linedefs must be either
	$c OBJ_NO_NONE or the number of an existing sidedef,
<li>sector references in sidedefs must be either
	$c OBJ_NO_NONE or the number of an existing sector.
</ul>

			<h3>Loading</h3>

The SEGS, SSECTORS, NODES, BLOCKMAP and REJECT lumps are
ignored. The other lumps are read into the level data
variables with a special case for VERTEXES ; vertices
that are not used by any linedef are ignored (such vertices
are believed to come from the nodes builder and therefore
be irrelevant to level editing). The linedefs vertices
references are updated if necessary.
<p>
Since the endianness of the wad files is fixed (little
endian) and thus not necessarily identical to the endianness
of the CPU, reading 2- and 4-byte integers from the file is
done through special endianness-independant routines.

			<h3>Saving</h3>

If $c MadeMapChanges is false, the SEGS, SSECTORS, NODES,
BLOCKMAP, REJECT and VERTEXES lumps are copied from the
original file. Else, they are output with a length of
zero bytes, except the VERTEXES lump that is created
from the the level data ($c NumVertices and $c Vertices).

<p>Since the endianness of the wad files is fixed (little
endian) and thus not necessarily identical to the endianness of
the CPU, writing 2- and 4-byte integers to the file is done
through special endianness-independant routines.

		<h2>Editing windows, or the lack of it</h2>

Too many global variables...
<p>
See "<code>_edit.h</code>".

		<h2>The editor loop</h2>

All the time the user spends editing a level is
spent within a certain function, the <dfn>editor loop</dfn>,
a.k.a. $c EditorLoop() in $c editloop.c.
It's essential for you to understand it
if you want to get how Yadex works right.
<p>
The $c EditorLoop() is an endless loop (okay, not
<em>really</em> endless) which, for each iteration,
first, refreshes the display,
second, waits for an event,
third, processes that event.
I could have put things in a different order
but I liked the idea of displaying something
<em>before</em> waiting for user input.
<p>
Because the event input and the graphical output
are complex and not-quite-synchronous processes,
I've tried to separate them.
$c EditorLoop() gets input events and processes them
and calls another function, $c edisplay_c::refresh(),
to take care of everything display related.
If you replaced $c edisplay_c::refresh() by a stub
(and did the same with a couple of functions in $c gfx.c
and $c input.c), you could perfectly well, if blindly,
run Yadex without a connection to an X server.
While you may object that this would be a pointless exercise
(to which I agree), it still proves the modularity of the design.
<p>
The $c edisplay_c::refresh() function
is also a very important one to understand,
at least if you work on graphical output.
It is discussed in another section but,
just to settle ideas, I thought I'd give you
here a bird's eye view of the whole thing.
If there is a single paragraph in this document
that you need to read, it's probably this one :
<ul>
<li>$c EditorLoop()
	<ul>
	<li>Call $c edisplay_c::refresh(),
		<ul>
		<li>Do some basic geometry management,
		<li>setup widgets according to editing session,
		<li>call the $c need_to_clear() method of the widgets
			to determine whether we need to redisplay
			everything from scratch,
		<li>if so, call the $c clear() method of the widgets
			and call $c ClearScreen() to clear the pixmap
			(if available) and make
			sure all subsequent graphical output will be sent
			to the pixmap (if available),
		<li>else, make sure all subsequent graphical ouput will
			be sent to the window and call the $c undraw()
			method of the widgets from the top down,
		<li>call the $c draw() method of the widgets from the bottom up,
		<li>call $c update_display() to refresh the physical display
			(if we're using the window, it's a no-op,
			if we're using the pixmap, call $c XCopyArea()).
		</ul>
	<li>call $c get_input_status() to get the next event,
	<li>process that event.
	</ul>
</ul>

Note that all graphical output is done from within $c edisplay_c::refresh().

		<h2>The display</h2>

			<h3>Logical and physical display : widgets</h3>

The display can be seen at two levels ;
the logical level and the physical level.
The physical level is just a rectangular
matrix of pixels. It's the contents of
the window/screen.
The logical level is more like "oh, there's
a window displayed at those coordinates".
<p>
There's obviously more to say on this...

			<h3>The pixmap</h3>

To further complicate matters,
there are two physical displays :
a window and a pixmap.
The role of the pixmap is to help avoid flicker.
Here's how it works :
<p>
As long as we do incremental changes to the display
(E.G. "undisplaying" the highlight on a vertex
or redisplaying the pointer coordinates),
we do it directly on the window.
<p>
But, if we have to redraw everything from scratch,
we have to clear the window first which generates
an annoying "flashing" of the screen.
To avoid this, we instead clear a pixmap,
do our display thing on it and then
put the pixmap onto the window, with $c XCopyArea().
The result is a flicker-less refresh.
<p>
The graphical routines from $c gfx.c
switch automatically to the pixmap if
$c ClearScreen() was called.
Thanks to this, that window vs. pixmap thing
is nearly transparent to the application functions.
$c edisplay_c::refresh() just forces
widgets that can undraw themselves to use the
window, not the pixmap.
<p>
But a pixmap is large.
For a 800x600 window in 64k colours, 937 kB.
And copying it to the window is obviously long.
So, on machines with little memory or a slow CPU,
the user might prefer to do without it.
That's what $c no_pixmap is for.

		<h2>The selection</h2>

			<h3>Introduction</h3>

From the user's point of view, the selection is a "list" of
objects.  I use the term "list" instead of "collection" because,
for certain operations, the order in which objects were added to
the selection is significant.
<p>
From the programmer's point of view, the selection is a
singly linked list of objects of this type :
<p>
<pre>typedef struct SelectionList *SelPtr;
struct SelectionList
   {
   SelPtr next;                 /* next in list */
   int objnum;                  /* object number */
   };</pre>
<p>
Note that the $c SelectionList structure
has no $c objtype field ;
the type of the object (THING, vertex...)
is implicit from the current mode
(the $c obj_type field from the $c edit_t
structure).
As a consequence, the selection cannot contain
objects of different types.
<p>
The selection manipulation functions are supposed to be
defined in $c selectn.c and declared in
$c selectn.h. Here they are :

<dl>
<dt><code>void SelectObject (SelPtr *s, int n)</code>
<dd>Adds object $c n at the beginning of list $c *s.
$c *s can be $c NULL ; it means the list is empty.
Warning : does not check that object $c n is not already
in the list.

<dt><code>void UnSelectObject (SelPtr *s, int n)</code>
<dd>Removes from list $c *s all occurrences of
object $c n.
If all objects are removed, sets $c *s to $c NULL.

<dt><code>void select_unselect_obj (SelPtr *s, int n)</code>
<dd>If the object $c n is already in the list $c *n, remove it.
If it's not, insert it at the beginning.
$c *s can be $c NULL ; it means the list is empty.

<dt><code>Bool IsSelected (SelPtr s, int n)</code>
<dd>Tells whether object $c n is in selection $c s.
$c s can be $c NULL ; it means the list is empty.

<dt><code>void ForgetSelection (SelPtr *s)</code>
<dd>Frees all memory allocated to list $c *s
and sets $c *s to $c NULL.

<dt><code>void DumpSelection (SelPtr s)</code>
<dd>Debugging function ; prints the contents of the
selection to $c stdout.
</dl>

Note that there is not selection iteration function.
Indeed, iterating through a selection is always done
by the application functions themselves, usually with
something like :
<p>
<pre>SelPtr cur;
for (cur = list; cur; cur = cur-&gt;next)
   do_something_with_object (cur-&gt;objnum);
</pre>

			<h3>Selecting in/out</h3>

When you draw a box with [<kbd>Ctrl</kbd>] depressed, the objects in
the box are added to the selection.
However, if some of those objects were already selected,
they are unselected.
So $c SelectObjectsInBox() cannot just add all
the objects in the box to the list or we would end up with
multiply selected objects. Wouldn't do us much good when
displaying the selection or dragging objects.
<p>
That's when $c select_unselect_obj() is used.

		<h2>The highlight</h2>

TBD

		<h2>Colours</h2>

The colour management system in very complex.
There are lots of things to say on that topic.
However, for most uses, you need to know only three functions :
<dl>
<dt>$c set_colour()
<dd>Set the current colour to a new value.
<dt>$c push_colour()
<dd>Save the current colour on the colour stack
and set the current colour to a new value.
<dt>$c pop_colour()
<dd>Set the current colour to the value
it had at the moment of the last call to $c push_colour().
</dl>

		<h2>Menus and pop-up windows</h2>

TBD

		<h2>Game graphics</h2>

			<h3>Doom graphics basics</h3>

Doom and its derivatives have two main formats for
graphics&nbsp;: pictures and plain bitmaps. Pictures are made of
columns which are in turn made of one or more posts. If there
are several posts in a column, they can be separated by void
space and thus the picture can have transparent areas. Pictures
are used for patches, sprites and the rest of the graphics (but
Yadex doesn't use them). Plain bitmaps are just arrays of pixels
and cannot contain transparent areas. That latter format is used
only for flats, which are all 64&times;64 bitmaps.

<p>Textures are made by pasting one or more patches onto a
rectangular buffer. The resulting image can be of course
transparent.

<p>For all formats, a pixel is a byte. The value of the byte
(between 0 and 255 inclusive) is an index into one of the
palettes contained in the <code>PLAYPAL</code> lump. To be able
to know the actual RGB colour of a pixel, it is necessary to
look up its value in the <code>PLAYPAL</code> (normally, only
the first palette is used).

			<h3>The <code>Img</code> class</h3>

<p>The <code>Img</code> class is used to store and manipulate
all game graphics (flats, patches, sprites and textures). It's a
palette-encoded rectangular array of pixels. The type
<code>img_pixel_t</code> is the type of a pixel; it's the same
as in the wad, that is a byte. The value of the elements of the
array is also the same as in the wad, that is an index into
<code>PLAYPAL</code>. Transparent areas are filled with colour
number 0 (which translates to black with all known iwads).
Unfortunately, colour 0 is also used in certain graphics which
causes them to be rendered with holes in them. This needs to be
fixed.

<p>The related functions are&nbsp;:
<pre>Img::Img             - default constructor
Img::Img             - constructor with dimensions
Img::~Img            - dtor
Img::is_null         - return true iff this is a null image
Img::width           - return the current width
Img::height          - return the current height
Img::buf             - return a const pointer on the buffer
Img::wbuf            - return a writable pointer on the buffer
Img::resize          - resize the image
clear_img            - clear a game image buffer
display_img          - display a game image
scale_img            - scale a game image
spectrify_img        - make a game image look vaguely like a spectre
LoadPicture          - read a picture from a wad file into an Img object</pre>

			<h3>Viewing graphics</h3>

<p>As is the case with saving graphics to a file, viewing
graphics would involve a lot of coding to do it in an optimized
fashion. Therefore it's done in a somewhat wasteful way&nbsp;:

<ol>
  <li>the image is put into an <code>Img</code> object
  <li>the <code>Img</code> is pasted onto the window or screen
</ol>

<p>The first step is done with
<code>DisplayFloorTexture()</code> (for flats) and
<code>LoadPicture()</code> (for other graphics). For textures,
<code>LoadPicture()</code> is called repeatedly on the same
<code>Img</code> object, once for each flat.

<p>The second step is done with
<code>display_img()</code>. It takes care of converting
Doom pixel values into actual pixel values needed by the
graphical API (which depend on a lot of factors like the video
mode, type and depth of visual, byte order of X server, etc.)
and getting the graphical API to display it on the window or
screen.

<p><code>display_pic()</code> combines fetching the image into
the game image buffer and displaying it.

<p><code>spectrify_img()</code> can be used on a game
image buffer to make it look more or less like a spectre.

			<h3>Saving graphics to file (screenshots etc.)</h3>

The basic idea is to

<ol>
  <li>get the image to save in an <code>Rgbbmp</code> buffer (with
    <code>window_to_rgbbmp()</code>),
  <li>save the <code>Rgbbmp</code> buffer to a file (with
    <code>rgbbmp_to_ppm()</code>).
</ol>

This is inefficient because, in many cases, the image could be
saved directly from the window to the file. This two-step
algorithm wastes memory (the buffer can be quite large) and
time. However, there is a good reason for doing things this way.

<p>The way to retrieve the image from the window or screen is
very dependent on the platform or video mode or type of visual
and the fashion in which the image is read is very dependent on
the graphic format. Therefore, if you want to use a one-step
algorithm and you have <var>n</var> platforms or video modes or
types of visuals and <var>m</var> graphic formats, you have to
write <var>n</var> &times; <var>m</var> functions. With a
two-step algorithm, you have only <var>n</var> + <var>m</var>
functions to write. As saving graphics to file is not a critical
function, I'd rather keep the code short and simple, unless the
result proves unacceptable.

		<h2>Saving</h2>

<p>One very important constraint in the saving code is that it
should never fail unless there is no reasonable alternative.
That's because, for users, saving is a <em>passage
obligé</em> to quit the program without losing their work.
Therefore, the saving code must be particularly robust and able
to recover from errors.

<p>This implies that the saving code <strong>must not need to
allocate new memory</strong>. To understand why, consider the
following scenario&nbsp;: you load a level and edit it until
Yadex uses all the available memory save a few kB. Then you want
to save it and Yadex says "nope, I don't have enough memory to
do that". From a user point of view, that sucks.

<p>Unfortunately, at present, many benign errors are considered
fatal when saving. For example, trying to save to a file on
which you don't have the necessary rights will make Yadex abort
even though this error is perfectly recoverable. This should be
fixed since it could cause users to lose data.

		<h2>Compile-time variables (defines)</h2>

<dl>
<dt>$c AYM_MOUSE_HACKS
<dd>Some experimental code by me to try to understand why,
under DOS, the mouse pointer moves 8 pixels at a time
(seems to depend on the mouse driver ?).
<p>
<dt>$c CIRRUS_PATCH
<dd>Dates back to DEU 5.21. Apparently, some code specific to
Cirrus VGA boards.
Does nothing unless $c Y_BGI is defined.
<p>
<dt>$c DEBUG
<dd>The obvious.
<p>
<dt>$c DIALOG
<dd>Experimental code by me to test the dialog box function
that Jim Flynn wrote for Deth in the beginning of 1998.
<p>
<dt>$c NO_CIRCLES
<dd>If your BGI driver does not support drawing circles,
define this and Yadex will draw squares instead.
<p>
<dt>$c OLD
<dd>Misc. obsolete stuff I didn't want to delete at the time.
Never define it or you'll break Yadex&nbsp;!
Code under <code>#ifdef OLD</code> should probably be removed.
<p>
<dt>$c OLD_GRID
<dd>Pre-1.5 grid (no dots, only lines).
<p>
<dt>$c OLD_METHOD
<dd>My cruft. Code thus <code>#ifdef</code>'d should probably be removed.
<p>
<dt>$c OLD_MESSAGE
<dd>My cruft. Code thus <code>#ifdef</code>'d should probably be removed.
<p>
<dt>$c ROUND_THINGS
<dd>Draw THINGS as circles (like DEU did), not as squares.
<p>
<dt>$c SWAP_TO_XMS
<dd>Comes from DEU : related to code supposed to use XMS as
"swap space". Apparently, was never used ?
<p>
<dt>$c Y_BGI
<dd>Use BGI for graphics output and BIOS for keyboard and mouse
input. Makes senses only for DOS + Borland C++ 4.0.
Exactly one of ($c Y_BGI, $c Y_X11) must be defined.
<p>
<dt>$c Y_DOS
<dd>Compile for DOS (with Borland C++ 4.0). Allows, among others,
the $c huge and $c far pointer modifiers.
Exactly one of ($c Y_DOS, $c Y_UNIX) must be defined.
<p>
<dt>$c Y_UNIX
<dd>Compile for Unix (with GCC 2.7.2). Causes, among other
things, "huge" and "far" to be <code>#define</code>'d to "".
Exactly one of ($c Y_DOS, $c Y_UNIX) must be defined.
<p>
<dt>$c Y_X11
<dd>Use X11 (Xlib) for graphics output, keyboard and mouse
input and other events.
Exactly one of ($c Y_BGI, $c Y_X11) must be defined.
</dl>

		<h2>Coding standards</h2>

Warning : this section was written when Yadex was still plain C.
Some of it may be inadequate or incomplete with C++.

			<h3>Indent style</h3>

BSD style with an indent width of 2.
<ul>
<li>tab stops every 8 characters,
<li>indent width is 2 spaces,
<li>line width limited to 80 characters,
<li>the braces have the same indentation as the text they contain,
<li>the body of a function is not indented.
</ul>

Many files still use Whitesmiths with an indent width of 3. They
will be reformatted.

Whitespace&nbsp;:
<ul>
<li>one space between the name of the function/statement and the "(",
<li>no space between the "(" and the first argument,
<li>no space between the end of the argument and the "," or ";",
<li>one space between the "," or ";" and the next argument,
<li>no space between the end of the argument and the ")",
<li>no space between the ")" and the ";",
<li>no space between the name of a variable and a "<code>[</code>",
<li>no space between a "<code>[</code>" and the character that follows,
<li>no space between a "<code>]</code>" and the character that precedes,
<li>one space on either side of binary operators,
<li>the dereferencing operator ("<code>*</code>") has a space to the left but
  no space to the right.
</ul>

<p>
Example :
<p>
<pre>static const char *foo (int n)
{
  for (stuff; stuff; stuff)
  {
    if (thingie || gadget ())
      call_this_one (with, three, exactly[arguments]);
    else
      dont ();
    call_that_one ();
  }
  return NULL;
}</pre>

			<h3>Identifiers</h3>

For variables and functions (and certain macros),
I use all-lower-case identifiers
with underscores where it seems appropriate.
For enums and most macros,
I use all-upper-case identifiers.
<p>
I consistently use the English spelling (E.G. "colour", not "color").

			<h3>Conditionals</h3>

The argument of <code>if</code> and <code>while</code> and the
second argument of <code>for</code> are booleans, not integers,
so you should provide a boolean expression. The following
expressions are not booleans&nbsp;:

<ul>
  <li>pointers,
  <li>the return value of <code>strcmp()</code>,
  <li>the return value of functions to return 0 to indicate
  success and non-zero to indicate failure,
</ul>

Therefore, don't write

<p><pre>
if (! fopen (filename, "r"))  // Test for failure
  ...
if (strcmp (str1, str2))  // Test for non-equality
  ...
if (! strcmp (str1, str2))  // Test for equality
  ...
if (remove (filename))  // Test for failure
  ...
</pre></p>

but

<p><pre>
if (fopen (filename, "r") <b>== NULL</b>)
  ...
if (strcmp (str1, str2) <b>!= 0</b>)
  ...
if (strcmp (str1, str2) <b>== 0</b>)
  ...
if (remove (filename) <b>!= 0</b>)
  ...
</pre></p>
  
On the other hand, when an expression is a boolean, you don't
need to add anything. <i>Don't</i> write <code>if (boolvar ==
true)</code>.

			<h3>General style</h3>

My general style is to try to make it look clear and pretty. If there
are several similar consecutive statements, I try to align what I can.
<p>
<pre>/* This is a long comment. A long comment is a comment
   that spans over several lines. See how I "typeset" it. */
func         (object, mutter    );
another_func (object, mumble, 46);
yet_another  (object, grunt     );  // Short comment.</pre>

			<h3>Code</h3>

Good code ;-).
<p>
<ul>
<li>Use $c const for all arguments passed by reference
unless they're modified.
<li>Use $c static for all functions and variables
unless they're extern.
<li>Be careful with $c int,
on some platforms, it's equivalent to $c short,
on others, it's equivalent to $c long.
<li>Whenever you need a fixed number of bytes,
use $c u16, $c i32, etc.
<li>Use prototypes.
<li>Prototype functions that take no args with "<code>foo (void);</code>",
 not "<code>foo ();</code>" (author's note : this is C-ish !).
<li>Try to avoid buffer overruns
by using $c y_snprintf() instead of $c sprintf(),
$c al_scps() instead of $c strcpy(),
$c al_saps() instead of $c strcat(), etc.
</ul>

			<h3>Functions to avoid</h3>

<dl>
  <dt><b><code>sprintf()</code></b>
  <dd>Prone to buffer overruns. Use <code>y_snprintf()</code> instead, as it
    uses <code>snprintf()</code> if it's available, and falls back on
    <code>sprintf()</code> if it isn't.

  <dt><b><code>snprintf()</code></b>
  <dd>Not supported widely enough yet. Use <code>y_snprintf()</code> instead.
    If <code>snprintf()</code> is available, it uses it (well, at least that's
    what it's meant to do). If not, it falls back on <code>sprintf()</code>.

  <dt><b><code>stricmp()</code></b> and <b><code>strcasecmp()</code></b>
  <dd>Not portable. Use <code>y_stricmp()</code> instead.
    <code>y_strnicmp()</code> is available as well.

</dl>

			<h3>Use the helpers</h3>

<dl>
  <dt><b>Converting an ASCII digit into its value</b>
  <dd>Don't subtract <code>'0'</code>. Use <code>dectoi()</code> or
    <code>hextoi()</code>.

  <dt><b>Testing whether a value is comprised between two bounds</b>
  <dd>Instead of <code>v &gt;= min &amp;&amp; v &lt;= max</code> you can use
    <code>within (v, min, max)</code>. It's inlined. The inverse test is
    provided by <code>outside()</code>.

  <dt><b>Comparing two file names</b>
  <dd>If you come from a Unix background, you'll be tempted to use
    <code>strcmp()</code>. If you come from a DOS background, you'll be tempted
    to use <code>y_stricmp()</code>. Neither is correct. Use
    <code>fncmp()</code>. In its current implementation, it's not correct
    either but it gets you a little bit closer. If only because it helps you
    to say what you mean.

  <dt><b>Telling whether is file name is absolute</b>
  <dd>This is not needed in many places. But when it is, use
    <code>is_absolute()</code>.

  <dt><b>Comparing two lump names</b>
  <dd>The code is peppered with <code>y_strnicmp(name1, name2,
    WAD_NAME)</code>. This should of course be replaced by a specialized
    function. This also applies to comparing flat names, texture names, sprite
    names, patch names, etc.

</dl>

			<h3>Includes</h3>

Put $c yadex.h first,
then any standard headers needed (E.G. $c math.h)
then all the Yadex headers needed by alphabetical order.
<p>
If the need arises to protect a Yadex header against multiple inclusion,
use this :
<p>
<pre>#ifndef YH_FOO
#define YH_FOO
(put the contents of the header here)
#endif</pre>

			<h3>File format</h3>

<table width="100%" bgcolor="#90a0c0" cellpadding="8">
  <tr>
    <td>
      The format of the source files is&nbsp;:
      <table cellspacing="0" cellpadding="0">
        <tr>
	  <td>
	    <ul>
	      <li>Character set&nbsp;
	      <li>Line length&nbsp;
	      <li>Line terminator&nbsp;
	      <li>Tab width&nbsp;
	    </ul>
	  </td>
	  <td>
	    ISO 8859-1 (a.k.a. Latin1)
	    <br>80 columns
	    <br>LF
	    <br>8
	  </td>
	</tr>
      </table>
</table>

		<h2>Notes</h2>

Here is the text of the notes in the source code.
<p>
<dl>
<dt>1
<dd>It's important to set the $c line_width to 1
and not 0 for GCs that have the $c GXxor function,
for the following reason.
<p>
Those GCs are used for objects that should be "undrawn" by
drawing them again, E.G. the highlight.
Now, imagine the following scenario :
you highlight a linedef and then press, say, page up to
make the window scroll. This is not an incremental change
to the display so everything is redrawn from scratch onto
the pixmap. The pixmap is <code>XCopyArea()</code>'d onto the window,
the linedef still highlighted. Then, Yadex realizes that
the map coordinates of the pointer have changed so the
linedef is not highlighted anymore. It dutifully unhighlights
the linedef. But $c XDrawLine() on a window does not use the
same algorithm as on a pixmap (attempts to use the blitter
on the video card). So the first line and the second don't
coincide exactly and the result is a trail of yellow pixels
where the highlight used to be.
<p>
That's why I use a $c line_width
sure that the same algorithm is used both for pixmap output
and for window output.

</dl>

<p><hr>AYM $SELF_DATE
</body>
</html>

